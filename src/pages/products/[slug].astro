---
/**
 * Product Detail Page
 * 
 * RULE-005: Every product page must have a getStaticPaths function
 */
import Layout from '@layouts/Layout.astro';
import Header from '@components/Header.astro';
import Footer from '@components/Footer.astro';
import type { Product } from '@lib/types';
import CartButton from '@components/CartButton';
import { getAllProducts, getProductBySlug } from '@lib/db/queries';
import { isBtcpayConfigured } from '@lib/btcpay';

interface Props {
  product: Product;
}

export async function getStaticPaths() {
  try {
    const products = await getAllProducts();
    return products.map((product) => ({
      params: { slug: product.slug },
      props: { product },
    }));
  } catch (error) {
    console.error('Error generating static paths:', error);
    // Return empty array if database is not set up yet
    return [];
  }
}

// Helper function to strip HTML from price strings
function stripPriceHtml(price: string): string {
  return price.replace(/<[^>]*>/g, '').trim();
}

// Helper function to format price as USD
function formatPrice(price: string | undefined): string {
  if (!price) return 'Price unavailable';
  const cleanPrice = stripPriceHtml(price);
  const numericMatch = cleanPrice.match(/(\d+\.?\d*)/);
  if (numericMatch) {
    const numericValue = parseFloat(numericMatch[1]);
    return `${numericValue.toFixed(2)} USD`;
  }
  return cleanPrice;
}

const { slug } = Astro.params;
const product = await getProductBySlug(slug || '');

if (!product) {
  return Astro.redirect('/404');
}

const formattedPrice = formatPrice(product.price);
const colorAttribute = product.attributes?.nodes.find(attr => attr.name.toLowerCase() === 'color');
const sizeAttribute = product.attributes?.nodes.find(attr => attr.name.toLowerCase() === 'size');
const features = product.attributes?.nodes.filter(attr => 
  attr.name.toLowerCase() !== 'color' && attr.name.toLowerCase() !== 'size'
) || [];

// Get all images for gallery
const allImages = product.galleryImages?.nodes || [];
const primaryImage = product.image;
const displayImages = primaryImage 
  ? [primaryImage, ...allImages.filter(img => img.sourceUrl !== primaryImage.sourceUrl)]
  : allImages;
const hasMultipleImages = displayImages.length > 1;
const btcpayAvailable = isBtcpayConfigured();
---

<Layout title={product.name} hideHeader={true}>
  <main class="min-h-screen bg-white">
    <Header />

    <!-- Product Content -->
    <div class="p-0">
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-0 max-w-[1920px] mx-auto">
        <!-- Left Column: Product Image -->
        <div class="w-full lg:border-r lg:border-gray-200 py-0 pb-6 flex flex-col relative overflow-hidden">
          {displayImages.length > 0 ? (
            <div class="sm:px-16 px-0 flex-1 flex flex-col">
              <div class="w-full aspect-square bg-white relative overflow-hidden group" style="min-height: 0;">
                <div id="image-slider" class="relative h-full flex" style={`width: ${displayImages.length * 100}%; transition: transform 300ms cubic-bezier(0.4, 0, 0.2, 1);`}>
                  {displayImages.map((img, index) => (
                    <div class="shrink-0 h-full relative bg-white flex items-center justify-center" style={`width: ${100 / displayImages.length}%;`}>
                      <img
                        data-image-index={index}
                        src={img.sourceUrl}
                        alt={img.altText || product.name}
                        class="w-full h-full object-contain"
                        style="display: block;"
                        loading={index === 0 ? "eager" : "lazy"}
                        width="800"
                        height="800"
                        decoding="async"
                      />
                    </div>
                  ))}
                </div>
                {hasMultipleImages && (
                  <>
                    <button
                      id="image-prev"
                      class="absolute left-4 top-1/2 -translate-y-1/2 w-10 h-10 rounded-full bg-black opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center cursor-pointer z-10"
                      aria-label="Previous image"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                      </svg>
                    </button>
                    <button
                      id="image-next"
                      class="absolute right-4 top-1/2 -translate-y-1/2 w-10 h-10 rounded-full bg-black opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center cursor-pointer z-10"
                      aria-label="Next image"
                    >
                      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 text-white">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                      </svg>
                    </button>
                  </>
                )}
              </div>
              {hasMultipleImages && (
                <div class="flex w-full gap-2 mt-4">
                  {displayImages.map((img, index) => (
                    <button
                      data-dot-index={index}
                      class={`h-1 flex-1 transition-opacity ${
                        index === 0 ? 'bg-black' : 'bg-gray-300'
                      } hover:opacity-70 cursor-pointer`}
                      aria-label={`View image ${index + 1}`}
                    />
                  ))}
                </div>
              )}
            </div>
          ) : (
            <div class="w-full aspect-square bg-gray-100 flex items-center justify-center">
              <span class="text-gray-400">No image available</span>
            </div>
          )}

          <!-- Measurements Tray (Desktop Only) - Nested inside left column -->
          {product.measurements && (
            <div 
              id="measurements-tray"
              class="hidden lg:block absolute top-0 left-0 right-0 bottom-0 bg-white z-50 transform translate-x-full transition-transform duration-500 ease-in-out overflow-y-auto"
              style="will-change: transform;"
            >
              <div class="p-16 h-full flex flex-col">
                <!-- Close Button -->
                <button
                  id="measurements-close"
                  class="absolute top-8 right-8 w-10 h-10 flex items-center justify-center hover:bg-gray-100 transition-colors cursor-pointer"
                  aria-label="Close measurements"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </button>

                <!-- Measurements Content -->
                <div class="flex-1">
                  <h2 class="text-2xl font-bold uppercase tracking-wide mb-8">
                    <span class="text-black">■</span> MEASUREMENTS
                  </h2>
                  <div id="measurements-content" class="text-base leading-relaxed">
                    {/* Measurements will be rendered here */}
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>

        <!-- Right Column: Product Details -->
        <div class="flex flex-col py-0 pt-0 lg:pt-4">
          <!-- Breadcrumbs -->
          <nav class="text-sm text-gray-600 sm:px-8 px-4 pb-8" aria-label="Breadcrumb">
            <ol class="flex items-center gap-2">
              <li>
                <a href="/" class="hover:text-gray-900 transition-colors">HOME</a>
              </li>
              {product.productCategories?.nodes && product.productCategories.nodes.length > 0 && (
                <>
                  <li class="text-gray-400">/</li>
                  <li>
                    <a 
                      href={`/products?category=${encodeURIComponent(product.productCategories.nodes[0].slug)}`}
                      class="hover:text-gray-900 transition-colors"
                    >
                      {product.productCategories.nodes[0].name.toUpperCase()}
                    </a>
                  </li>
                </>
              )}
              <li class="text-gray-400">/</li>
              <li class="text-gray-900 font-medium" aria-current="page">
                {product.name.toUpperCase()}
              </li>
            </ol>
          </nav>

          <!-- Product Identifier -->
          <div class="text-xl font-bold uppercase tracking-wide text-gray-700 pb-0 sm:px-8 px-4">
            <!-- <span class="text-black">■</span> -->
             {product.name}
          </div>

          <!-- Price -->
          <div class="space-y-1 pt-4 sm:px-8 px-4">
            <div class="text-base tracking-wide">{formattedPrice}</div>
            <div class="text-xs text-gray-500">VAT EXCLUDED / EXCL. SHIPPING</div>
          </div>

          <!-- Size selector (when product has size inventory) -->
          {product.sizes && product.sizes.length > 0 && (
            <div class="pt-4 sm:px-8 px-4" data-product-slug={product.slug}>
              <div class="text-xs font-bold uppercase tracking-wide text-gray-600 mb-2">Size</div>
              <div class="flex flex-wrap gap-2" id="size-selector" role="group" aria-label="Select size">
                {product.sizes.map(({ size, quantity }) => (
                  <button
                    type="button"
                    data-size={size}
                    data-quantity={quantity}
                    disabled={quantity === 0}
                    class="size-option min-w-[3rem] px-3 py-2 text-sm border border-gray-300 rounded hover:border-gray-800 transition-colors cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed disabled:line-through"
                    aria-pressed="false"
                    aria-label={`Size ${size}${quantity === 0 ? ', out of stock' : `, ${quantity} available`}`}
                  >
                    {size}
                  </button>
                ))}
              </div>
            </div>
          )}

          {product.sizes && product.sizes.length > 0 && (
            <script define:vars={{ productSlug: product.slug }}>
              (function() {
                const container = document.querySelector('[data-product-slug]');
                const slug = typeof productSlug === 'string' ? productSlug : '';
                if (!container || !slug) return;
                const selector = document.getElementById('size-selector');
                if (!selector) return;
                fetch('/api/product/' + encodeURIComponent(slug) + '/sizes', { credentials: 'same-origin' })
                  .then(function(r) { return r.json(); })
                  .then(function(data) {
                    if (!data.sizes || !Array.isArray(data.sizes)) return;
                    const bySize = {};
                    data.sizes.forEach(function(s) { bySize[s.size] = s.quantity; });
                    selector.querySelectorAll('.size-option').forEach(function(btn) {
                      const size = btn.getAttribute('data-size');
                      const qty = size != null && bySize[size] !== undefined ? bySize[size] : 0;
                      btn.setAttribute('data-quantity', String(qty));
                      btn.disabled = qty === 0;
                      btn.setAttribute('aria-label', 'Size ' + size + (qty === 0 ? ', out of stock' : ', ' + qty + ' available'));
                      if (qty === 0) {
                        btn.classList.add('opacity-50', 'cursor-not-allowed', 'line-through');
                        btn.classList.remove('hover:border-gray-800');
                      } else {
                        btn.classList.remove('opacity-50', 'cursor-not-allowed', 'line-through');
                        btn.classList.add('hover:border-gray-800');
                      }
                    });
                    const wrapper = document.getElementById('cart-button-wrapper');
                    const fallbackBtn = document.getElementById('cart-button-fallback-btn');
                    if (wrapper && fallbackBtn) {
                      const selected = wrapper.getAttribute('data-selected-size');
                      if (selected && (bySize[selected] === undefined || bySize[selected] === 0)) {
                        wrapper.removeAttribute('data-selected-size');
                        fallbackBtn.disabled = true;
                        fallbackBtn.textContent = 'SELECT SIZE';
                        selector.querySelectorAll('.size-option').forEach(function(btn) {
                          btn.classList.remove('border-black', 'bg-black', 'text-white');
                          btn.classList.add('border-gray-300');
                          btn.setAttribute('aria-pressed', 'false');
                        });
                      }
                    }
                  })
                  .catch(function() {});
              })();
            </script>
          )}

          <!-- Add to Cart Button -->
          <div class="pt-4 sm:px-8 px-4 pb-4 min-h-[60px]" id="cart-button-wrapper">
            {product.stockStatus === 'IN_STOCK' ? (
              <>
                {/* Static fallback button - renders immediately, prevents flash */}
                <div id="cart-button-fallback" class="min-h-[52px]">
                  <button
                    id="cart-button-fallback-btn"
                    class="w-full px-6 py-4 text-[1.5rem] bg-black text-white uppercase font-semibold hover:opacity-70 transition-opacity cursor-pointer disabled:bg-gray-400 disabled:cursor-not-allowed"
                    data-stripe-url={product.stripeCheckoutUrl || ''}
                    data-product-id={product.id}
                    data-has-sizes={product.sizes && product.sizes.length > 0 ? 'true' : 'false'}
                    {...(product.sizes && product.sizes.length > 0 ? { disabled: true } : {})}
                  >
                    {product.sizes && product.sizes.length > 0 ? 'SELECT SIZE' : '+ ADD TO CART'}
                  </button>
                </div>
                {/* React component - replaces fallback when hydrated */}
                <div id="cart-button-react" style="display: none;">
                  <CartButton
                    client:load
                    productId={product.id}
                    productName={product.name}
                    stripeCheckoutUrl={product.stripeCheckoutUrl}
                    sizes={product.sizes}
                    btcpayAvailable={btcpayAvailable}
                  />
                </div>
              </>
            ) : (
              <div class="h-[52px]"></div>
            )}
          </div>

          <!-- Short Description -->
          {product.shortDescription ? (
            <div class="text-base leading-relaxed border-t border-gray-200 pt-6 sm:px-8 px-4 pb-6">
              <div set:html={product.shortDescription} />
            </div>
          ) : null}

          <!-- Full Description -->
          {product.description ? (
            <div class="text-base leading-relaxed border-t border-gray-200 pt-6 sm:px-8 px-4 pb-6">
              <div set:html={product.description} />
            </div>
          ) : null}

          <!-- Details and Materials Section -->
          <div class="grid grid-cols-1 md:grid-cols-2 gap-8 border-t border-gray-200 pt-6 sm:px-8 px-4 pb-6">
            <!-- Details Column -->
            <div class="space-y-3">
              <div class="text-xs font-bold uppercase tracking-wide mb-4">
                <span class="text-black">■</span> DETAILS
              </div>
              {product.details ? (
                <div class="text-base leading-relaxed [&_ul]:list-disc [&_ul]:ml-6 [&_ul]:space-y-1 [&_li]:leading-relaxed">
                  <div set:html={product.details} />
                </div>
              ) : (
                <>
                  {colorAttribute && colorAttribute.options.length > 0 && (
                    <div class="text-base">
                      <span class="font-medium uppercase">COLOR:</span> {colorAttribute.options.join(', ').toUpperCase()}
                    </div>
                  )}
                  {product.measurements && (
                    <div class="text-base">
                      <button 
                        id="measurements-toggle"
                        class="uppercase underline hover:no-underline cursor-pointer"
                        aria-label="View measurements"
                      >
                        MEASUREMENTS
                      </button>
                    </div>
                  )}
                  {sizeAttribute && sizeAttribute.options.length > 0 && (
                    <div class="text-base">
                      <span class="font-medium uppercase">SIZE:</span> {sizeAttribute.options.join(', ').toUpperCase()}
                    </div>
                  )}
                </>
              )}
            </div>

            <!-- Materials Column -->
            <div class="space-y-3">
              <div class="text-xs font-bold uppercase tracking-wide mb-4">
                <span class="text-black">■</span> MATERIALS
              </div>
              <div class="text-base leading-relaxed [&_ul]:list-disc [&_ul]:ml-6 [&_ul]:space-y-1 [&_li]:leading-relaxed">
                {product.materials ? (
                  <div set:html={product.materials} />
                ) : (
                  <div>Product materials information available upon request.</div>
                )}
              </div>
            </div>
          </div>

          <!-- Product Features (hidden for shell jackets without product.features; thermo jackets have it) -->
          {(product.features || (features.length > 0 && !product.name.toLowerCase().includes('shell jacket'))) && (
            <div class="space-y-3 border-t border-gray-200 pt-8 sm:px-8 px-4 pb-8">
              <div class="text-xs font-bold uppercase tracking-wide mb-4">
                <span class="text-black">■</span> PRODUCT FEATURES
              </div>
              {product.features ? (
                <div class="text-base leading-relaxed [&_ul]:list-disc [&_ul]:ml-6 [&_ul]:space-y-1 [&_li]:leading-relaxed">
                  <div set:html={product.features} />
                </div>
              ) : (
                <ul class="space-y-2 text-base leading-relaxed">
                  {features.map((feature) => (
                    <li class="flex items-start">
                      <span class="mr-2 text-black">•</span>
                      <span>{feature.options.map(opt => `${feature.name.toLowerCase()} ${opt}`).join(', ')}</span>
                    </li>
                  ))}
                </ul>
              )}
            </div>
          )}
        </div>
      </div>
    </div>

    <!-- Border line before footer -->
    <div class="border-t border-gray-200 -mx-8"></div>

    <!-- Measurements Tray (Mobile Only) - Bottom Sheet -->
    {product.measurements && (
      <div 
        id="measurements-tray-mobile"
        class="lg:hidden fixed inset-0 z-50 pointer-events-none"
      >
        <!-- Backdrop -->
        <div 
          id="measurements-backdrop-mobile"
          class="absolute inset-0 bg-black opacity-0 transition-opacity duration-300 pointer-events-none"
        ></div>
        
        <!-- Tray -->
        <div 
          id="measurements-tray-content-mobile"
          class="absolute bottom-0 left-0 right-0 bg-white rounded-t-2xl shadow-2xl transform translate-y-full transition-transform duration-300 ease-out max-h-[90vh] flex flex-col pointer-events-auto"
          style="will-change: transform;"
        >
          <!-- Drag Handle -->
          <div class="flex justify-center pt-4 pb-2">
            <div class="w-12 h-1 bg-gray-300 rounded-full"></div>
          </div>
          
          <!-- Header -->
          <div class="px-6 py-4 border-b border-gray-200 flex items-center justify-between">
            <h2 class="text-xl font-bold uppercase tracking-wide">
              <span class="text-black">■</span> MEASUREMENTS
            </h2>
            <button
              id="measurements-close-mobile"
              class="w-8 h-8 flex items-center justify-center hover:bg-gray-100 transition-colors cursor-pointer rounded-full"
              aria-label="Close measurements"
            >
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>

          <!-- Measurements Content -->
          <div class="flex-1 overflow-y-auto px-6 py-6">
            <div id="measurements-content-mobile" class="text-base leading-relaxed">
              {/* Measurements will be rendered here */}
            </div>
          </div>
        </div>
      </div>
    )}

    <Footer />
  </main>
</Layout>

{hasMultipleImages && (
  <script define:vars={{ images: displayImages.map(img => ({ url: img.sourceUrl, alt: img.altText || product.name })) }}>
    (function() {
      const imageSlider = document.getElementById('image-slider');
      const dotButtons = document.querySelectorAll('[data-dot-index]');
      const prevButton = document.getElementById('image-prev');
      const nextButton = document.getElementById('image-next');
      const imageContainer = imageSlider?.parentElement;
      let currentIndex = 0;
      let isTransitioning = false;

      // Touch/swipe state
      let touchStartX = 0;
      let touchStartY = 0;
      let touchEndX = 0;
      let touchEndY = 0;
      const minSwipeDistance = 50; // Minimum distance in pixels for a swipe

      if (!imageSlider || dotButtons.length === 0) return;

      function updateImage(index, direction = 'next') {
        if (isTransitioning || index === currentIndex) return;
        
        isTransitioning = true;
        const translatePercent = (index * 100) / images.length;
        imageSlider.style.transform = `translateX(-${translatePercent}%)`;

        // Update active indicator immediately
        dotButtons.forEach((btn, i) => {
          if (i === index) {
            btn.classList.remove('bg-gray-300');
            btn.classList.add('bg-black');
          } else {
            btn.classList.remove('bg-black');
            btn.classList.add('bg-gray-300');
          }
        });

        currentIndex = index;
        
        // Reset transition lock after animation completes
        setTimeout(() => {
          isTransitioning = false;
        }, 300);
      }

      // Handle dot navigation
      dotButtons.forEach((button, index) => {
        button.addEventListener('click', () => {
          const direction = index > currentIndex ? 'next' : 'prev';
          updateImage(index, direction);
        });
      });

      // Handle arrow navigation
      if (prevButton) {
        prevButton.addEventListener('click', () => {
          const newIndex = currentIndex === 0 ? images.length - 1 : currentIndex - 1;
          updateImage(newIndex, 'prev');
        });
      }

      if (nextButton) {
        nextButton.addEventListener('click', () => {
          const newIndex = currentIndex === images.length - 1 ? 0 : currentIndex + 1;
          updateImage(newIndex, 'next');
        });
      }

      // Touch/swipe handlers for mobile
      if (imageContainer) {
        imageContainer.addEventListener('touchstart', (e) => {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
        }, { passive: true });

        imageContainer.addEventListener('touchmove', (e) => {
          // Allow vertical scrolling but track horizontal movement
          touchEndX = e.touches[0].clientX;
          touchEndY = e.touches[0].clientY;
        }, { passive: true });

        imageContainer.addEventListener('touchend', () => {
          if (!touchStartX || !touchEndX) return;

          const deltaX = touchStartX - touchEndX;
          const deltaY = touchStartY - touchEndY;
          const absDeltaX = Math.abs(deltaX);
          const absDeltaY = Math.abs(deltaY);

          // Only trigger swipe if horizontal movement is greater than vertical (more horizontal than vertical)
          // and exceeds minimum distance
          if (absDeltaX > absDeltaY && absDeltaX > minSwipeDistance) {
            if (deltaX > 0) {
              // Swiped left - go to next image
              const newIndex = currentIndex === images.length - 1 ? 0 : currentIndex + 1;
              updateImage(newIndex, 'next');
            } else {
              // Swiped right - go to previous image
              const newIndex = currentIndex === 0 ? images.length - 1 : currentIndex - 1;
              updateImage(newIndex, 'prev');
            }
          }

          // Reset touch values
          touchStartX = 0;
          touchStartY = 0;
          touchEndX = 0;
          touchEndY = 0;
        }, { passive: true });
      }
    })();
  </script>
)}

{product.sizes && product.sizes.length > 0 && (
  <script is:inline>
    (function() {
      const wrapper = document.getElementById('cart-button-wrapper');
      const fallbackBtn = document.getElementById('cart-button-fallback-btn');
      const sizeOptions = document.querySelectorAll('#size-selector .size-option:not([disabled])');
      if (!wrapper || !fallbackBtn || sizeOptions.length === 0) return;

      function setSelectedSize(size) {
        wrapper.setAttribute('data-selected-size', size);
        fallbackBtn.disabled = false;
        fallbackBtn.textContent = '+ ADD TO CART';
        try { wrapper.dispatchEvent(new CustomEvent('size-selected', { detail: { size } })); } catch (e) {}
        document.querySelectorAll('#size-selector .size-option').forEach(function(btn) {
          btn.classList.remove('border-black', 'bg-black', 'text-white');
          btn.classList.add('border-gray-300');
          btn.setAttribute('aria-pressed', 'false');
          if (btn.getAttribute('data-size') === size) {
            btn.classList.add('border-black', 'bg-black', 'text-white');
            btn.classList.remove('border-gray-300');
            btn.setAttribute('aria-pressed', 'true');
          }
        });
      }

      sizeOptions.forEach(function(btn) {
        btn.addEventListener('click', function() {
          var size = this.getAttribute('data-size');
          if (size) setSelectedSize(size);
        });
      });
    })();
  </script>
)}

{product.measurements && (
  <script define:vars={{ measurementsData: product.measurements }}>
    (function() {
      const measurementsToggle = document.getElementById('measurements-toggle');
      const measurementsTray = document.getElementById('measurements-tray');
      const measurementsClose = document.getElementById('measurements-close');
      const measurementsContent = document.getElementById('measurements-content');
      
      // Mobile elements
      const measurementsTrayMobile = document.getElementById('measurements-tray-mobile');
      const measurementsTrayContentMobile = document.getElementById('measurements-tray-content-mobile');
      const measurementsBackdropMobile = document.getElementById('measurements-backdrop-mobile');
      const measurementsCloseMobile = document.getElementById('measurements-close-mobile');
      const measurementsContentMobile = document.getElementById('measurements-content-mobile');
      
      if (!measurementsToggle) return;

      // Parse measurements data (could be JSON or HTML)
      function renderMeasurements(data) {
        try {
          // Try to parse as JSON first
          const parsed = JSON.parse(data);
          
          // If it's an array of measurement objects, render as table
          if (Array.isArray(parsed) && parsed.length > 0) {
            let html = '<div class="space-y-8">';
            
            parsed.forEach((measurementGroup, groupIndex) => {
              if (measurementGroup.sizes && Array.isArray(measurementGroup.sizes)) {
                const firstSize = measurementGroup.sizes[0];
                
                // Check if this is denim format (has waist, lowHip, lengths) or simple format (has measurements)
                const isDenimFormat = firstSize.waist && firstSize.lowHip && firstSize.lengths;
                
                if (isDenimFormat) {
                  // Denim format: complex table with waist, lowHip, and multiple lengths
                  html += '<div class="mb-8">';
                  if (measurementGroup.sizeRange) {
                    html += `<h3 class="text-lg font-bold uppercase mb-4">${measurementGroup.sizeRange}</h3>`;
                  }
                  html += '<div class="overflow-x-auto">';
                  html += '<table class="w-full border-collapse text-sm">';
                  html += '<thead><tr class="border-b-2 border-black">';
                  html += '<th class="text-left py-3 px-4 font-bold uppercase">Size</th>';
                  html += '<th class="text-left py-3 px-4 font-bold uppercase">Waist</th>';
                  html += '<th class="text-left py-3 px-4 font-bold uppercase">Low Hip</th>';
                  html += '<th class="text-left py-3 px-4 font-bold uppercase">32" Length</th>';
                  html += '<th class="text-left py-3 px-4 font-bold uppercase">30" Length</th>';
                  html += '<th class="text-left py-3 px-4 font-bold uppercase">34" Length</th>';
                  html += '</tr></thead><tbody>';
                  
                  measurementGroup.sizes.forEach(size => {
                    html += '<tr class="border-b border-gray-200">';
                    html += `<td class="py-3 px-4 font-medium">${size.size || ''}</td>`;
                    html += `<td class="py-3 px-4">${size.waist?.inch || ''} (${size.waist?.cm || ''}cm)</td>`;
                    html += `<td class="py-3 px-4">${size.lowHip?.inch || ''} (${size.lowHip?.cm || ''}cm)</td>`;
                    html += `<td class="py-3 px-4">${size.lengths?.['32"']?.inch || ''} (${size.lengths?.['32"']?.cm || ''}cm)</td>`;
                    html += `<td class="py-3 px-4">${size.lengths?.['30"']?.inch || ''} (${size.lengths?.['30"']?.cm || ''}cm)</td>`;
                    html += `<td class="py-3 px-4">${size.lengths?.['34"']?.inch || ''} (${size.lengths?.['34"']?.cm || ''}cm)</td>`;
                    html += '</tr>';
                  });
                  
                  html += '</tbody></table>';
                  html += '</div>';
                  html += '</div>';
                } else {
                  // Simple format: flat measurements object (tee shirts, jackets)
                  html += '<div class="overflow-x-auto">';
                  if (measurementGroup.sizeRange) {
                    html += `<h3 class="text-lg font-bold uppercase mb-4">${measurementGroup.sizeRange}</h3>`;
                  }
                  html += '<table class="w-full border-collapse text-sm">';
                  html += '<thead><tr class="border-b-2 border-black">';
                  
                  html += '<th class="text-left py-3 px-4 font-bold uppercase">Size</th>';
                  Object.keys(firstSize.measurements || {}).forEach(key => {
                    html += `<th class="text-left py-3 px-4 font-bold uppercase">${key}</th>`;
                  });
                  
                  html += '</tr></thead><tbody>';
                  
                  measurementGroup.sizes.forEach(size => {
                    html += '<tr class="border-b border-gray-200">';
                    html += `<td class="py-3 px-4 font-medium">${size.size || ''}</td>`;
                    Object.values(size.measurements || {}).forEach(value => {
                      html += `<td class="py-3 px-4">${value}</td>`;
                    });
                    html += '</tr>';
                  });
                  
                  html += '</tbody></table>';
                  html += '</div>';
                }
              }
            });
            
            html += '</div>';
            return html;
          }
        } catch (e) {
          // Not JSON, treat as HTML
        }
        
        // Fallback: render as HTML
        return data;
      }

      // Set initial content for both desktop and mobile
      if (measurementsContent) {
        measurementsContent.innerHTML = renderMeasurements(measurementsData);
      }
      if (measurementsContentMobile) {
        measurementsContentMobile.innerHTML = renderMeasurements(measurementsData);
      }

      // Desktop tray functions
      function openTrayDesktop() {
        if (!measurementsTray) return;
        measurementsTray.classList.remove('translate-x-full');
        measurementsTray.classList.add('translate-x-0');
      }

      function closeTrayDesktop() {
        if (!measurementsTray) return;
        measurementsTray.classList.remove('translate-x-0');
        measurementsTray.classList.add('translate-x-full');
      }

      function isTrayOpenDesktop() {
        if (!measurementsTray) return false;
        return !measurementsTray.classList.contains('translate-x-full');
      }

      // Mobile tray functions
      function openTrayMobile() {
        if (!measurementsTrayMobile || !measurementsTrayContentMobile || !measurementsBackdropMobile) return;
        measurementsTrayMobile.classList.remove('pointer-events-none');
        measurementsBackdropMobile.classList.remove('opacity-0');
        measurementsBackdropMobile.classList.add('opacity-50');
        measurementsBackdropMobile.classList.remove('pointer-events-none');
        measurementsTrayContentMobile.classList.remove('translate-y-full');
        measurementsTrayContentMobile.classList.add('translate-y-0');
        measurementsTrayContentMobile.style.transform = 'translateY(0)';
        // Prevent body scroll
        document.body.style.overflow = 'hidden';
      }

      function closeTrayMobile() {
        if (!measurementsTrayMobile || !measurementsTrayContentMobile || !measurementsBackdropMobile) return;
        measurementsBackdropMobile.classList.remove('opacity-50');
        measurementsBackdropMobile.classList.add('opacity-0');
        measurementsTrayContentMobile.classList.remove('translate-y-0');
        measurementsTrayContentMobile.classList.add('translate-y-full');
        measurementsTrayContentMobile.style.transform = '';
        // Re-enable body scroll
        document.body.style.overflow = '';
        // Reset pointer events after animation
        setTimeout(() => {
          measurementsTrayMobile.classList.add('pointer-events-none');
          measurementsBackdropMobile.classList.add('pointer-events-none');
        }, 300);
      }

      function isTrayOpenMobile() {
        if (!measurementsTrayContentMobile) return false;
        return !measurementsTrayContentMobile.classList.contains('translate-y-full');
      }

      // Swipe-down functionality for mobile tray
      if (measurementsTrayContentMobile) {
        let swipeStartY = 0;
        let swipeCurrentY = 0;
        let swipeStartTime = 0;
        let isSwiping = false;
        let contentScrollTop = 0;
        const swipeThreshold = 100; // Minimum pixels to swipe before closing
        const swipeVelocityThreshold = 0.5; // Minimum velocity (px/ms) to close

        // Get the scrollable content area
        const scrollableContent = measurementsTrayContentMobile.querySelector('.overflow-y-auto');

        measurementsTrayContentMobile.addEventListener('touchstart', (e) => {
          if (!isTrayOpenMobile()) return;
          
          swipeStartY = e.touches[0].clientY;
          swipeCurrentY = swipeStartY;
          swipeStartTime = Date.now();
          isSwiping = false;
          
          // Check if content is scrolled - if so, only allow swipe from top area
          if (scrollableContent) {
            contentScrollTop = scrollableContent.scrollTop;
          }
          
          // Only start swiping if:
          // 1. Content is at the top (scrollTop === 0), OR
          // 2. Touch started in the header area (first 100px)
          const touchY = e.touches[0].clientY;
          const trayRect = measurementsTrayContentMobile.getBoundingClientRect();
          const relativeY = touchY - trayRect.top;
          
          if (contentScrollTop === 0 || relativeY < 100) {
            isSwiping = true;
            // Disable transition during swipe for smooth dragging
            measurementsTrayContentMobile.style.transition = 'none';
            measurementsBackdropMobile.style.transition = 'none';
          }
        }, { passive: true });

        measurementsTrayContentMobile.addEventListener('touchmove', (e) => {
          if (!isSwiping || !isTrayOpenMobile()) return;
          
          swipeCurrentY = e.touches[0].clientY;
          const deltaY = swipeCurrentY - swipeStartY;
          
          // Only allow downward swipes (positive deltaY)
          if (deltaY > 0) {
            // Prevent default scrolling while swiping
            e.preventDefault();
            
            // Apply transform to drag the tray down
            measurementsTrayContentMobile.style.transform = `translateY(${deltaY}px)`;
            
            // Update backdrop opacity based on drag distance
            const maxHeight = measurementsTrayContentMobile.offsetHeight;
            const opacity = Math.max(0, 0.5 * (1 - deltaY / maxHeight));
            measurementsBackdropMobile.style.opacity = opacity.toString();
          }
        }, { passive: false });

        measurementsTrayContentMobile.addEventListener('touchend', () => {
          if (!isSwiping || !isTrayOpenMobile()) return;
          
          const deltaY = swipeCurrentY - swipeStartY;
          const swipeDuration = Date.now() - swipeStartTime;
          const swipeVelocity = deltaY / Math.max(swipeDuration, 1);
          
          // Re-enable transition
          measurementsTrayContentMobile.style.transition = '';
          measurementsBackdropMobile.style.transition = '';
          
          // Close if:
          // 1. Swiped down more than threshold, OR
          // 2. Swiped with sufficient velocity downward
          if (deltaY > swipeThreshold || (deltaY > 50 && swipeVelocity > swipeVelocityThreshold)) {
            closeTrayMobile();
          } else {
            // Snap back to open position
            measurementsTrayContentMobile.style.transform = 'translateY(0)';
            measurementsBackdropMobile.style.opacity = '0.5';
          }
          
          // Reset swipe state
          isSwiping = false;
          swipeStartY = 0;
          swipeCurrentY = 0;
          swipeStartTime = 0;
        }, { passive: true });
      }

      // Check if mobile or desktop
      function isMobile() {
        return window.innerWidth < 1024; // lg breakpoint
      }

      // Toggle handler - opens appropriate tray based on screen size
      measurementsToggle.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (isMobile()) {
          if (isTrayOpenMobile()) {
            closeTrayMobile();
          } else {
            openTrayMobile();
          }
        } else {
          if (isTrayOpenDesktop()) {
            closeTrayDesktop();
          } else {
            openTrayDesktop();
          }
        }
      });

      // Desktop close handler
      if (measurementsClose) {
        measurementsClose.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          closeTrayDesktop();
        });
      }

      // Mobile close handlers
      if (measurementsCloseMobile) {
        measurementsCloseMobile.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          closeTrayMobile();
        });
      }

      if (measurementsBackdropMobile) {
        measurementsBackdropMobile.addEventListener('click', () => {
          closeTrayMobile();
        });
      }

      // Close on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          if (isMobile() && isTrayOpenMobile()) {
            closeTrayMobile();
          } else if (!isMobile() && isTrayOpenDesktop()) {
            closeTrayDesktop();
          }
        }
      });

      // Desktop: Close on click outside the tray
      if (measurementsTray) {
        document.addEventListener('click', (e) => {
          if (!isTrayOpenDesktop() || isMobile()) return;
          
          // If click is outside the tray, close it
          if (!measurementsTray.contains(e.target) && e.target !== measurementsToggle) {
            closeTrayDesktop();
          }
        });

        // Prevent clicks inside the tray from closing it
        measurementsTray.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      }

      // Handle window resize - close mobile tray if switching to desktop
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (!isMobile() && isTrayOpenMobile()) {
            closeTrayMobile();
          }
        }, 100);
      });
    })();
  </script>
)}

{/* Replace static button with React component when ready */}
{product.stockStatus === 'IN_STOCK' && (
  <script define:vars={{ stripeCheckoutUrl: product.stripeCheckoutUrl, productId: product.id }}>
    (function() {
      const fallback = document.getElementById('cart-button-fallback');
      const reactContainer = document.getElementById('cart-button-react');
      const fallbackBtn = document.getElementById('cart-button-fallback-btn');
      
      if (!fallback || !reactContainer || !fallbackBtn) return;
      
      // Attach click handler to fallback button
      fallbackBtn.addEventListener('click', async () => {
        if (stripeCheckoutUrl) {
          window.location.href = stripeCheckoutUrl;
          return;
        }
        
        try {
          const response = await fetch(`/api/stripe-checkout?productId=${productId}`);
          if (!response.ok) throw new Error('Failed to get checkout URL');
          const data = await response.json();
          if (data.checkoutUrl) {
            window.location.href = data.checkoutUrl;
          }
        } catch (err) {
          console.error('Error getting checkout URL:', err);
        }
      });
      
      // Check if React component has hydrated
      const checkReactReady = setInterval(() => {
        const reactButton = reactContainer.querySelector('button');
        if (reactButton && reactButton.offsetParent !== null) {
          // React component is ready, swap them
          fallback.style.display = 'none';
          reactContainer.style.display = 'block';
          clearInterval(checkReactReady);
        }
      }, 50);
      
      // Cleanup after 5 seconds - keep fallback if React never loads
      setTimeout(() => {
        clearInterval(checkReactReady);
      }, 5000);
    })();
  </script>
)}

