---
/**
 * Products Listing Page
 */
import Layout from '@layouts/Layout.astro';
import Header from '@components/Header.astro';
import Footer from '@components/Footer.astro';
import FilterTray from '@components/FilterTray.astro';
import type { Product, ProductCategory } from '@lib/types';
import { getAllProducts, getAllCategories } from '@lib/db/queries';

// Get category filter from URL query parameter
const selectedCategorySlug = Astro.url.searchParams.get('category') || null;

// Fetch products and categories from database
let products: Product[] = [];
let categories: ProductCategory[] = [];

try {
  products = await getAllProducts(selectedCategorySlug || undefined);
  categories = await getAllCategories();
} catch (error) {
  console.error('Error fetching products:', error);
  // Fallback to empty arrays if database is not set up yet
}

// Filter products by selected category (client-side filtering also available)
let filteredProducts = products;
if (selectedCategorySlug) {
  filteredProducts = products.filter((product) => {
    return product.productCategories?.nodes.some(
      (category) => category.slug === selectedCategorySlug
    );
  });
}

// Helper function to strip HTML from price strings
function stripPriceHtml(price: string): string {
  return price.replace(/<[^>]*>/g, '').trim();
}
---

<Layout title="All Products" hideHeader={true}>
  <main class="min-h-screen bg-white">
    <Header />

    <!-- Main Content -->
    <div class="max-w-[1920px] mx-auto flex flex-col gap-0">
      <div id="shop-navigation" class="w-full px-2 lg:px-8 py-2 lg:py-4 flex flex-col gap-2 lg:flex-row lg:items-center lg:justify-between lg:gap-0 lg:relative">
        {/* Categories - top row on mobile, centered on desktop */}
        {categories.length > 0 && (
          <>
            <div class="category-scroll-container w-full overflow-x-auto lg:w-auto lg:overflow-visible order-first lg:order-none lg:absolute lg:left-1/2 lg:transform lg:-translate-x-1/2 pb-0">
              <ul class="flex items-center gap-6 flex-nowrap lg:flex-wrap" id="category-filters">
                <li>
                  <button
                    data-category=""
                    class={`text-md uppercase hover:opacity-70 transition-opacity whitespace-nowrap cursor-pointer ${
                      !selectedCategorySlug ? 'text-[#00cd00] font-bold' : 'text-black'
                    }`}
                  >
                    ALL
                  </button>
                </li>
                {categories.map((category) => (
                  <li>
                    <button
                      data-category={category.slug}
                      class={`text-md uppercase hover:opacity-70 transition-opacity whitespace-nowrap cursor-pointer ${
                        selectedCategorySlug === category.slug ? 'text-[#00cd00] font-bold' : 'text-black'
                      }`}
                    >
                      {category.name}
                    </button>
                  </li>
                ))}
              </ul>
            </div>
            <div class="border-b border-gray-200 lg:hidden -mx-2 lg:mx-0"></div>
          </>
        )}
        {/* Season text and Filter button - same row on mobile, separate on desktop */}
        <div class="flex items-center justify-between lg:contents">
          <h1 class="text-md text-black font-bold uppercase order-2 lg:order-none season-title">MMXXVI-I</h1>
          <button 
            id="filters-button"
            class="text-md text-black uppercase hover:opacity-70 transition-opacity order-3 lg:order-none cursor-pointer"
          >
            FILTERS
          </button>
        </div>
      </div>

      {filteredProducts.length === 0 ? (
        <div class="text-center py-12 empty-state" id="empty-state">
          <p class="text-gray-500">
            {selectedCategorySlug ? 'No products found in this category.' : 'No products found.'}
          </p>
          <p class="text-sm text-gray-400 mt-2">
            {selectedCategorySlug ? (
              <button class="text-[#00cd00] hover:opacity-70 underline show-all-btn cursor-pointer">
                View all products
              </button>
            ) : (
              'No products available.'
            )}
          </p>
        </div>
      ) : (
        <div class="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 gap-0 product-grid" id="products-grid">
          {filteredProducts.map((product) => {
            // Format price: extract numeric value and format as USD XX.XX
            let formattedPrice: string | null = null;
            if (product.price) {
              const cleanPrice = stripPriceHtml(product.price);
              // Extract numeric value (handles various formats like $50.00, 50.00, Â£50, etc.)
              const numericMatch = cleanPrice.match(/(\d+\.?\d*)/);
              if (numericMatch) {
                const numericValue = parseFloat(numericMatch[1]);
                formattedPrice = `USD ${numericValue.toFixed(2)}`;
              }
            }
            
            // Find hover image based on product type
            const isShellJacket = product.name.toLowerCase().includes('shell jacket');
            const isShellJacketBlue = product.name.toLowerCase().includes('shell jacket') && product.name.toLowerCase().includes('blue');
            const hasMultipleImages = product.galleryImages?.nodes && product.galleryImages.nodes.length > 1;
            
            let hoverImage = null;
            let showHoverEffect = false;
            
            if (isShellJacketBlue && hasMultipleImages && product.galleryImages?.nodes) {
              // For blue shell jacket: use second image that's different from primary
              hoverImage = product.galleryImages.nodes.find(img => img.sourceUrl !== product.image?.sourceUrl);
              showHoverEffect = !!hoverImage;
            } else if (isShellJacket && hasMultipleImages && product.galleryImages?.nodes) {
              // For other shell jackets: use thermochromic if available
              const thermochromicImage = product.galleryImages.nodes.find(img => 
                img.sourceUrl.toLowerCase().includes('thermochromic')
              );
              
              hoverImage = thermochromicImage;
              showHoverEffect = !!hoverImage && hoverImage.sourceUrl !== product.image?.sourceUrl;
            } else if (hasMultipleImages && product.galleryImages?.nodes) {
              // For other products: use second image that's different from primary
              hoverImage = product.galleryImages.nodes.find(img => img.sourceUrl !== product.image?.sourceUrl);
              showHoverEffect = !!hoverImage;
            }
            
            // Extract sizes and colors from attributes
            const productSizes: string[] = [];
            const productColors: string[] = [];
            product.attributes?.nodes.forEach(attr => {
              if (attr.name.toLowerCase() === 'size') {
                productSizes.push(...attr.options);
              }
              if (attr.name.toLowerCase() === 'color') {
                productColors.push(...attr.options);
              }
            });
            const productTypeNames = product.productCategories?.nodes.map(c => c.name) || [];

            return (
              <a
                href={`/products/${product.slug}`}
                class="group product-item cursor-pointer"
                data-categories={JSON.stringify(product.productCategories?.nodes.map(c => c.slug) || [])}
                data-sizes={JSON.stringify(productSizes)}
                data-colors={JSON.stringify(productColors)}
                data-product-types={JSON.stringify(productTypeNames)}
              >
                {/* Product Image - Square with light gray background */}
                <div class="w-full aspect-square bg-gray-100 mb-2 flex items-center justify-center overflow-hidden relative">
                  {product.image ? (
                    <>
                      {/* Primary image */}
                      <img
                        src={product.image.sourceUrl}
                        alt={product.image.altText || product.name}
                        class={`w-full h-full object-contain transition-opacity duration-300 absolute inset-0 ${
                          showHoverEffect
                            ? 'opacity-100 group-hover:opacity-0' 
                            : 'group-hover:opacity-90'
                        }`}
                      />
                      {/* Hover image - visible on hover */}
                      {showHoverEffect && hoverImage && (
                        <img
                          src={hoverImage.sourceUrl}
                          alt={hoverImage.altText || product.name}
                          class="w-full h-full object-contain transition-opacity duration-300 opacity-0 group-hover:opacity-100 absolute inset-0"
                        />
                      )}
                    </>
                  ) : (
                    <span class="text-gray-400 text-sm">No image</span>
                  )}
                </div>
                
                {/* Product Info */}
                <div class="space-y-1 text-center">
                  <h2 class="text-base font-bold uppercase text-[#00cd00] group-hover:opacity-70 transition-opacity product-title">
                    {product.name}
                  </h2>
                  
                  {formattedPrice && (
                    <p class="text-sm text-black font-medium mt-2 product-price">
                      {formattedPrice}
                    </p>
                  )}
                </div>
              </a>
            );
          })}
        </div>
      )}
    </div>

    <FilterTray products={products} categories={categories} />

    <Footer />
  </main>
</Layout>

<style>
  /* Custom scrollbar styling */
  ::-webkit-scrollbar {
    width: 8px;
  }
  
  ::-webkit-scrollbar-track {
    background: #f9fafb;
  }
  
  ::-webkit-scrollbar-thumb {
    background: #e5e7eb;
    border-radius: 4px;
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: #d1d5db;
  }
  
  /* Grid divider lines - shared borders for consistent 1px thickness */
  /* Grid container provides top, left, and bottom borders */
  .product-grid {
    border-top: 1px solid #e5e7eb;
    border-left: 1px solid #e5e7eb;
    border-bottom: 1px solid #e5e7eb;
  }
  
  /* Each product provides right and bottom borders */
  /* This ensures every product appears to have borders on all 4 sides */
  /* without doubling up where borders meet */
  .product-grid > a {
    border-right: 1px solid #e5e7eb;
    border-bottom: 1px solid #e5e7eb;
    padding: 1rem;
  }
  
  /* Remove horizontal padding on mobile (2 columns) */
  @media (max-width: 1023px) {
    .product-grid > a {
      padding-left: 0;
      padding-right: 0;
    }
  }
  
  /* Remove bottom border from last row items to avoid doubling with grid bottom border */
  .product-grid > a.no-bottom-border {
    border-bottom: none;
  }
  
  /* Hide scrollbar on category filters */
  .category-scroll-container {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
  
  .category-scroll-container::-webkit-scrollbar {
    display: none;  /* Chrome, Safari, Opera */
  }
</style>

<script>
  // Type declarations for window properties
  declare global {
    interface Window {
      openFilterTray?: () => void;
    }
  }

  // Client-side category filtering
  (function() {
    const categoryButtons = document.querySelectorAll('#category-filters button[data-category]');
    const productItems = document.querySelectorAll('.product-item');
    const productsGrid = document.getElementById('products-grid');
    let emptyState = document.getElementById('empty-state');
    
    // Early return if no products or buttons
    if (categoryButtons.length === 0 || productItems.length === 0) {
      return;
    }
    
    // Create empty state element if it doesn't exist (for client-side filtering)
    if (!emptyState) {
      const container = productsGrid ? productsGrid.parentNode : document.querySelector('.max-w-\\[1920px\\]');
      if (container) {
        emptyState = document.createElement('div');
        emptyState.id = 'empty-state';
        emptyState.className = 'text-center py-12 empty-state hidden';
        emptyState.innerHTML = `
          <p class="text-gray-500">No products found in this category.</p>
          <p class="text-sm text-gray-400 mt-2">
            <button class="text-[#00cd00] hover:opacity-70 underline show-all-btn cursor-pointer">View all products</button>
          </p>
        `;
        if (productsGrid) {
          container.insertBefore(emptyState, productsGrid);
        } else {
          container.appendChild(emptyState);
        }
      }
    }

    function updateLastRowBorders() {
      // Get all visible products
      const visibleProducts = Array.from(productItems).filter(item => !item.classList.contains('hidden'));
      
      if (visibleProducts.length === 0) return;
      
      // Remove the class from all products first
      productItems.forEach(item => item.classList.remove('no-bottom-border'));
      
      // Determine grid columns based on viewport width
      const columnsPerRow = window.innerWidth < 1024 ? 2 : 3;
      
      // Calculate how many items are in the last row
      const totalVisible = visibleProducts.length;
      const itemsInLastRow = totalVisible % columnsPerRow || columnsPerRow;
      
      // Remove bottom border from last row items
      const startIndex = totalVisible - itemsInLastRow;
      for (let i = startIndex; i < totalVisible; i++) {
        visibleProducts[i].classList.add('no-bottom-border');
      }
    }

    function filterProducts(categorySlug: string | null, trayFilters?: { size: string[]; color: string[]; 'product-type': string[] }) {
      let visibleCount = 0;
      
      productItems.forEach((item) => {
        // Category filter
        const categoriesAttr = item.getAttribute('data-categories');
        if (!categoriesAttr) {
          item.classList.add('hidden');
          return;
        }
        
        const productCategories = JSON.parse(categoriesAttr);
        let shouldShow = !categorySlug || productCategories.includes(categorySlug);
        
        // Apply tray filters if provided
        if (trayFilters && shouldShow) {
          const sizesAttr = item.getAttribute('data-sizes');
          const colorsAttr = item.getAttribute('data-colors');
          const productTypesAttr = item.getAttribute('data-product-types');
          
          const productSizes = sizesAttr ? JSON.parse(sizesAttr) : [];
          const productColors = colorsAttr ? JSON.parse(colorsAttr) : [];
          const productTypes = productTypesAttr ? JSON.parse(productTypesAttr) : [];
          
          // Size filter: if sizes are selected, product must have at least one matching size
          if (trayFilters.size.length > 0) {
            const hasMatchingSize = trayFilters.size.some(size => productSizes.includes(size));
            if (!hasMatchingSize) {
              shouldShow = false;
            }
          }
          
          // Color filter: if colors are selected, product must have at least one matching color
          if (trayFilters.color.length > 0 && shouldShow) {
            const hasMatchingColor = trayFilters.color.some(color => productColors.includes(color));
            if (!hasMatchingColor) {
              shouldShow = false;
            }
          }
          
          // Product type filter: if types are selected, product must have at least one matching type
          if (trayFilters['product-type'].length > 0 && shouldShow) {
            const hasMatchingType = trayFilters['product-type'].some(type => productTypes.includes(type));
            if (!hasMatchingType) {
              shouldShow = false;
            }
          }
        }
        
        if (shouldShow) {
          item.classList.remove('hidden');
          visibleCount++;
        } else {
          item.classList.add('hidden');
        }
      });

      // Show/hide empty state
      if (visibleCount === 0) {
        if (emptyState) {
          emptyState.classList.remove('hidden');
          // Update empty state message
          const message = emptyState.querySelector('p.text-gray-500');
          const action = emptyState.querySelector('p.text-sm');
          if (message) {
            message.textContent = categorySlug ? 'No products found in this category.' : 'No products found.';
          }
          if (action && categorySlug) {
            action.innerHTML = '<button class="text-[#00cd00] hover:opacity-70 underline show-all-btn">View all products</button>';
          }
        }
        if (productsGrid) productsGrid.classList.add('hidden');
      } else {
        if (emptyState) emptyState.classList.add('hidden');
        if (productsGrid) productsGrid.classList.remove('hidden');
        
        // Remove bottom borders from last visible row to avoid doubling with grid bottom border
        updateLastRowBorders();
      }

      // Update URL without page reload
      const url = new URL(window.location.href);
      if (categorySlug) {
        url.searchParams.set('category', categorySlug);
      } else {
        url.searchParams.delete('category');
      }
      window.history.pushState({}, '', url.toString());

      // Update active button states
      categoryButtons.forEach((btn) => {
        const btnCategory = btn.getAttribute('data-category');
        if ((!categorySlug && btnCategory === '') || (categorySlug === btnCategory)) {
          btn.classList.add('text-[#00cd00]', 'font-bold');
          btn.classList.remove('text-black');
        } else {
          btn.classList.remove('text-[#00cd00]', 'font-bold');
          btn.classList.add('text-black');
        }
      });
    }

    // Add click handlers to category buttons
    categoryButtons.forEach((button) => {
      button.addEventListener('click', (e) => {
        e.preventDefault();
        const categorySlug = button.getAttribute('data-category');
        filterProducts(categorySlug === '' ? null : categorySlug);
      });
    });

    // Handle "show all" button in empty state
    const showAllBtn = document.querySelector('.show-all-btn');
    if (showAllBtn) {
      showAllBtn.addEventListener('click', () => {
        filterProducts(null);
      });
    }

    // Handle browser back/forward buttons
    window.addEventListener('popstate', () => {
      const urlParams = new URLSearchParams(window.location.search);
      const categorySlug = urlParams.get('category');
      filterProducts(categorySlug);
    });
    
    // Update borders on initial load
    updateLastRowBorders();
    
    // Update borders on window resize (in case grid columns change)
    let resizeTimeout: ReturnType<typeof setTimeout> | undefined;
    window.addEventListener('resize', () => {
      if (resizeTimeout) clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        updateLastRowBorders();
      }, 100);
    });

    // Filter tray button handler
    const filtersButton = document.getElementById('filters-button');
    if (filtersButton && window.openFilterTray) {
      filtersButton.addEventListener('click', () => {
        window.openFilterTray?.();
      });
    }

    // Listen for filter tray changes
    window.addEventListener('filtersChanged', ((e: CustomEvent) => {
      const activeFilters = e.detail;
      const urlParams = new URLSearchParams(window.location.search);
      const categorySlug = urlParams.get('category');
      filterProducts(categorySlug, activeFilters);
    }) as EventListener);
  })();
</script>
