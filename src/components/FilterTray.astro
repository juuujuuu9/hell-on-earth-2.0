---
/**
 * Filter Tray Component
 * Sliding filter panel that opens from the right side
 */
import type { Product, ProductCategory } from '@lib/types';

interface Props {
  products: Product[];
  categories: ProductCategory[];
}

const { products = [], categories = [] } = Astro.props;

// Extract unique sizes from product attributes
const sizes = new Set<string>();
products.forEach(product => {
  product.attributes?.nodes.forEach(attr => {
    if (attr.name.toLowerCase() === 'size') {
      attr.options.forEach(option => sizes.add(option));
    }
  });
});
const sortedSizes = Array.from(sizes).sort();

// Extract unique colors from product attributes and group by main color
function getMainColor(colorName: string): string {
  const lowerColor = colorName.toLowerCase().trim();
  
  // Special cases - check these first
  if (lowerColor.includes('therma glow')) return 'black';
  if (lowerColor.includes('camo')) return 'camo';
  
  // Handle combinations like "blackwhite" (no separator)
  if (lowerColor.includes('blackwhite') || (lowerColor.includes('black') && lowerColor.includes('white') && !lowerColor.includes(' '))) {
    return 'black';
  }
  
  // For multi-word colors, split and take first word
  const parts = lowerColor.split(/[\s-]+/);
  if (parts.length > 1) {
    return parts[0];
  }
  
  // Single word colors return as-is
  return lowerColor;
}

// Map of main color -> array of original color names
const colorMap = new Map<string, string[]>();

// Extract colors from product attributes
products.forEach(product => {
  if (product.attributes?.nodes) {
    product.attributes.nodes.forEach(attr => {
      // Check for color attribute (case-insensitive)
      const attrName = attr.name.toLowerCase().trim();
      if (attrName === 'color' && attr.options && Array.isArray(attr.options)) {
        attr.options.forEach(option => {
          if (option && typeof option === 'string' && option.trim()) {
            const mainColor = getMainColor(option);
            if (!colorMap.has(mainColor)) {
              colorMap.set(mainColor, []);
            }
            // Only add if not already in the array for this main color
            const originalColors = colorMap.get(mainColor)!;
            if (!originalColors.includes(option)) {
              originalColors.push(option);
            }
          }
        });
      }
    });
  }
});

// Get sorted unique main colors
const sortedColors = Array.from(colorMap.keys()).sort();

// Product types are the categories
const productTypes = categories.map(cat => cat.name).sort();
---

<div id="filter-tray-overlay" class="fixed inset-0 bg-black pointer-events-none transition-opacity duration-300 z-40 hidden" style="opacity: 0;">
</div>

<div id="filter-tray" class="fixed top-0 right-0 h-full w-80 bg-white shadow-2xl transform translate-x-full transition-transform duration-300 ease-in-out z-50">
  <div class="flex flex-col h-full">
    <!-- Header -->
    <div class="flex items-center justify-between p-6 border-b border-gray-200">
      <h2 class="text-lg font-bold uppercase text-black">FILTERS</h2>
      <div class="flex items-center gap-4">
        <button 
          id="filter-tray-clear"
          class="text-sm text-gray-400 uppercase hover:text-black transition-colors cursor-pointer"
        >
          CLEAR ALL
        </button>
        <button 
          id="filter-tray-close"
          class="text-black hover:opacity-70 transition-opacity cursor-pointer"
          aria-label="Close filters"
        >
          ✕
        </button>
      </div>
    </div>

    <!-- Filter Options -->
    <div class="flex-1 overflow-y-auto p-6">
      <ul class="space-y-6">
        <!-- SIZE Filter -->
        <li>
          <button 
            class="w-full flex items-center justify-between text-left text-gray-400 uppercase hover:opacity-70 transition-opacity cursor-pointer"
            data-filter-type="size"
            aria-expanded="false"
            aria-controls="filter-size-options"
          >
            <span>SIZE</span>
            <span>→</span>
          </button>
          <div id="filter-size-options" class="hidden mt-4 pl-4 space-y-3">
            {sortedSizes.length > 0 ? (
              sortedSizes.map((size) => (
                <label class="flex items-center cursor-pointer group">
                  <input 
                    type="checkbox" 
                    value={size}
                    data-filter="size"
                    class="mr-3 cursor-pointer"
                  />
                  <span class="text-gray-600 uppercase text-sm group-hover:text-black transition-colors">{size}</span>
                </label>
              ))
            ) : (
              <p class="text-gray-400 text-sm italic">No sizes available</p>
            )}
          </div>
        </li>

        <!-- COLOR Filter -->
        <li>
          <button 
            class="w-full flex items-center justify-between text-left text-gray-400 uppercase hover:opacity-70 transition-opacity cursor-pointer"
            data-filter-type="color"
            aria-expanded="false"
            aria-controls="filter-color-options"
          >
            <span>COLOR</span>
            <span>→</span>
          </button>
          <div id="filter-color-options" class="hidden mt-4 pl-4 space-y-3">
            {sortedColors.length > 0 ? (
              sortedColors.map((color) => (
                <label class="flex items-center cursor-pointer group">
                  <input 
                    type="checkbox" 
                    value={color}
                    data-filter="color"
                    data-main-color={color}
                    data-original-colors={JSON.stringify(colorMap.get(color) || [])}
                    class="mr-3 cursor-pointer"
                  />
                  <span class="text-gray-600 uppercase text-sm group-hover:text-black transition-colors">{color}</span>
                </label>
              ))
            ) : (
              <p class="text-gray-400 text-sm italic">No colors available</p>
            )}
          </div>
        </li>

        <!-- PRODUCT TYPE Filter -->
        <li>
          <button 
            class="w-full flex items-center justify-between text-left text-gray-400 uppercase hover:opacity-70 transition-opacity cursor-pointer"
            data-filter-type="product-type"
            aria-expanded="false"
            aria-controls="filter-product-type-options"
          >
            <span>PRODUCT TYPE</span>
            <span>→</span>
          </button>
          <div id="filter-product-type-options" class="hidden mt-4 pl-4 space-y-3">
            {productTypes.length > 0 ? (
              productTypes.map((type) => (
                <label class="flex items-center cursor-pointer group">
                  <input 
                    type="checkbox" 
                    value={type}
                    data-filter="product-type"
                    class="mr-3 cursor-pointer"
                  />
                  <span class="text-gray-600 uppercase text-sm group-hover:text-black transition-colors">{type}</span>
                </label>
              ))
            ) : (
              <p class="text-gray-400 text-sm italic">No product types available</p>
            )}
          </div>
        </li>
      </ul>
    </div>

    <!-- Footer with Apply Button -->
    <div class="border-t border-gray-200 p-6">
      <button 
        id="filter-tray-apply"
        class="w-full bg-black text-white uppercase py-4 px-6 hover:opacity-90 transition-opacity cursor-pointer font-bold"
      >
        APPLY
      </button>
    </div>
  </div>
</div>

<script>
  // Type declarations for window properties
  declare global {
    interface Window {
      openFilterTray?: () => void;
      getActiveFilters?: () => Record<string, string[]>;
      clearAllFilters?: () => void;
    }
  }

  (function() {
    const filterTray = document.getElementById('filter-tray') as HTMLElement | null;
    const filterOverlay = document.getElementById('filter-tray-overlay') as HTMLElement | null;
    const filterTrayClose = document.getElementById('filter-tray-close') as HTMLElement | null;
    const filterTrayClear = document.getElementById('filter-tray-clear') as HTMLElement | null;
    const filterTrayApply = document.getElementById('filter-tray-apply') as HTMLElement | null;
    const filterButtons = document.querySelectorAll('[data-filter-type]');
    
    if (!filterTray || !filterOverlay || !filterTrayClose) return;

    // Open filter tray
    function openFilterTray() {
      if (!filterTray || !filterOverlay) return;
      filterTray.classList.remove('translate-x-full');
      filterOverlay.classList.remove('hidden', 'pointer-events-none');
      filterOverlay.classList.add('pointer-events-auto');
      filterOverlay.style.opacity = '0.4';
      document.body.style.overflow = 'hidden';
    }

    // Close filter tray
    function closeFilterTray() {
      if (!filterTray || !filterOverlay) return;
      filterTray.classList.add('translate-x-full');
      filterOverlay.classList.remove('pointer-events-auto');
      filterOverlay.classList.add('pointer-events-none', 'hidden');
      filterOverlay.style.opacity = '0';
      document.body.style.overflow = '';
    }

    // Toggle filter options
    filterButtons.forEach(button => {
      button.addEventListener('click', () => {
        const filterType = button.getAttribute('data-filter-type');
        const optionsPanel = document.getElementById(`filter-${filterType}-options`);
        const isExpanded = button.getAttribute('aria-expanded') === 'true';
        
        if (optionsPanel) {
          if (isExpanded) {
            optionsPanel.classList.add('hidden');
            button.setAttribute('aria-expanded', 'false');
          } else {
            optionsPanel.classList.remove('hidden');
            button.setAttribute('aria-expanded', 'true');
          }
        }
      });
    });

    // Filter functionality
    const filterCheckboxes = document.querySelectorAll('[data-filter]');
    let activeFilters: Record<string, string[]> = {
      size: [],
      color: [],
      'product-type': []
    };

    function collectFilters(): Record<string, string[]> {
      // Reset active filters
      const filters: Record<string, string[]> = {
        size: [],
        color: [],
        'product-type': []
      };

      // Collect checked filters
      filterCheckboxes.forEach((checkbox) => {
        const input = checkbox as HTMLInputElement;
        if (input.checked) {
          const filterType = input.getAttribute('data-filter');
          const value = input.value;
          
          if (filterType && filters[filterType as keyof typeof filters]) {
            // For color filters, expand main color to original colors
            if (filterType === 'color') {
              const originalColorsAttr = input.getAttribute('data-original-colors');
              if (originalColorsAttr) {
                try {
                  const originalColors = JSON.parse(originalColorsAttr) as string[];
                  filters.color.push(...originalColors);
                } catch (e) {
                  // Fallback to main color if parsing fails
                  filters.color.push(value);
                }
              } else {
                filters.color.push(value);
              }
            } else {
              filters[filterType as keyof typeof filters].push(value);
            }
          }
        }
      });

      return filters;
    }

    function applyFilters() {
      activeFilters = collectFilters();
      // Trigger filter event
      window.dispatchEvent(new CustomEvent('filtersChanged', { detail: activeFilters }));
      // Close the tray after applying
      closeFilterTray();
    }

    // Clear all filters
    function clearAllFilters() {
      filterCheckboxes.forEach((checkbox) => {
        const input = checkbox as HTMLInputElement;
        input.checked = false;
      });
      // Update active filters state but don't apply yet
      activeFilters = {
        size: [],
        color: [],
        'product-type': []
      };
    }

    // Close button handler
    filterTrayClose.addEventListener('click', closeFilterTray);

    // Clear button handler
    if (filterTrayClear) {
      filterTrayClear.addEventListener('click', clearAllFilters);
    }

    // Apply button handler
    if (filterTrayApply) {
      filterTrayApply.addEventListener('click', applyFilters);
    }

    // Overlay click handler
    filterOverlay.addEventListener('click', closeFilterTray);

    // ESC key handler
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !filterTray.classList.contains('translate-x-full')) {
        closeFilterTray();
      }
    });

    // Expose open function globally for the FILTERS button
    window.openFilterTray = openFilterTray;

    // Expose filter state and clear function
    window.getActiveFilters = () => collectFilters();
    window.clearAllFilters = clearAllFilters;
  })();
</script>
